/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpcMiner.h"
#include <openssl/sha.h>
#include <limits.h>
#include <pthread.h>
#include <stdlib.h>
#include <stdio.h>

#define MENUGETTRANSACTIONID 1
#define MENUGETCHALLENGE 2
#define MENUGETTRANSACTIONSTATUS 3
#define MENUGETWINNER 4
#define MENUGETSEED 5
#define MENUMINERAR 6 
#define KILL_THREADS 1
#define RUN_THREADS 0
#define SUCCESS 1
#define EXHAUST 2
#define LATE 0


char *host;
int threads_flag = RUN_THREADS;
// CLIENT *clnt;

typedef struct thread_data {
   int x_i, x_f, id, status, tID;
   char seed[40];
   CLIENT *clnt;
} thread_data;


int imprimeMenu(){
	int opcao;
	printf("1 - GETTRANSACTIONID\n");
	printf("2 - GETCHALLENGE\n");
	printf("3 - GETTRANSACTIONSTATUS\n");
	printf("4 - GETWINNER\n");
	printf("5 - GETSEED\n");
	printf("6 - MINERAR\n");
	printf("Escolha uma opcao: ");
	scanf("%d", &opcao);
	return opcao;
}


int getTransactionID(CLIENT *clnt){
	void *kk;
	int *result = gettransactionid_100(kk, clnt);
	if (result == NULL){
		fprintf(stderr, "PROBLEMA NA CHAMADA RPC\n");
		exit(0);
	}
	return *(result);
}

int getChallenge(CLIENT *clnt, int transactionID){
	int *result = getchallenge_100(&transactionID, clnt);
	if (result == NULL){
		fprintf(stderr, "PROBLEMA NA CHAMADA RPC\n");
		exit(0);
	}
	return *(result);
}

int getTransactionStatus(CLIENT *clnt, int transactionID){
	int *result = gettransactionstatus_100(&transactionID, clnt);
	if (result == NULL){
		fprintf(stderr, "PROBLEMA NA CHAMADA RPC\n");
		exit(0);
	}
	return *(result);
}

int submitChallenge(CLIENT *clnt, challengeTuple ct){
	int *result = submitchallenge_100(&ct, clnt);
	if (result == NULL){
		fprintf(stderr, "PROBLEMA NA CHAMADA RPC\n");
		exit(0);
	}
	return *(result);
}

int getWinner(CLIENT *clnt, int transactionID){
	int *result = getwinner_100(&transactionID, clnt);
	if (result == NULL){
		fprintf(stderr, "PROBLEMA NA CHAMADA RPC\n");
		exit(0);
	}
	return *(result);
}

row getSeed(CLIENT *clnt, int transactionID){
	row *result = getseed_100(&transactionID, clnt);
	if (result == NULL){
		fprintf(stderr, "PROBLEMA NA CHAMADA RPC\n");
		exit(0);
	}
	return *(result);
}

void *brute(void *arg){
	thread_data *tdata = (thread_data *) arg;
	challengeTuple ct;
	int xi = tdata->x_i, xf = tdata->x_f, id = tdata->id;
	ct.transactionId = tdata->tID;
	ct.clientID = 777;
	CLIENT *clnt = tdata->clnt;
	// CLIENT *clnt;
	printf("ate aqui %d\n", id);
	fflush(stdout);
	// clnt = clnt_create(host, PROG, VERSAO, "udp");
	if (clnt == (CLIENT *) NULL) {
		clnt_pcreateerror(host);
		printf("ERRO AO CRIAR CLIENTE %d\n", id);
		fflush(stdout);
		exit(1);
	}
	int finish = 0;
	for (int i = xi; i <= xf && !finish; ++i){
		if (threads_flag == KILL_THREADS){
			// tdata->status = LATE;
			finish = 1;
			break;
			// pthread_exit(NULL);
		}
		sprintf(ct.seed, "%d", i);
		// printf("seed encontrada = %s\n", ct.seed);
		
		int resultado = submitChallenge(clnt, ct);
		// printf("resultado = %d\n", resultado = submitChallenge(clnt, ct));
		if (resultado == 1){
			printf("resolvido transaction = %d!!!! ID = %d seed = %d\n", ct.transactionId, id, i);
			strcpy(tdata->seed, ct.seed);
			threads_flag = KILL_THREADS;
			tdata->status = SUCCESS;
			finish = 1;
			break;
			// pthread_exit(NULL);
		}
		if (resultado == 2){
			
			printf("alguem ja resolveu e nao fui eu transaction = %d!!!!\n", ct.transactionId);
			threads_flag = KILL_THREADS;
			// tdata->status = LATE;
			finish = 1;
			break;
			// pthread_exit(NULL);
		}
	}

	// if (!finish)tdata->status = EXHAUST;
	// clnt_destroy (clnt);
	pthread_exit(NULL);
}


int
main (int argc, char *argv[])
{
	char *host;
	
	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	printf("%s\n", host);
	CLIENT *clnt;
	clnt = clnt_create(argv[1], PROG, VERSAO, "udp");
	char data[] = "lorenzo";
	size_t length = strlen(data);

	unsigned char hash[SHA_DIGEST_LENGTH];
	SHA1(data, length, hash);
	// for (int i = 0; i < SHA_DIGEST_LENGTH; ++i)
	// 	printf("%02x", hash[i]);
	// printf("\n");
	while (1){
		int opt = imprimeMenu();
		printf("opcao = %d\n", opt);
		if (opt == MENUGETTRANSACTIONID){
			printf("transacao corrente: %d\n", getTransactionID(clnt));
		}
		else if (opt == MENUGETCHALLENGE){
			int id;
			printf("digite o ID da transacao: ");
			scanf("%d", &id);
			printf("DESAFIO = %d\n", getChallenge(clnt, id));
		}
		else if (opt == MENUGETTRANSACTIONSTATUS){
			int id;
			printf("digite o ID da transacao: ");
			scanf("%d", &id);
			printf("STATUS = %d\n", getTransactionStatus(clnt, id));
		}
		else if (opt == 777){ //RETIRAR DEPOIS *testando submitchallenge
			challengeTuple ct;
			ct.clientID = 777;
			strcpy(ct.seed, "asdfasd3");
			// ct.seed = "lorenzo";
			ct.transactionId = 0;
			printf("resultado = %d\n", submitChallenge(clnt, ct));
		}
		else if (opt == MENUGETWINNER){
			int id;
			printf("digite o ID da transacao: ");
			scanf("%d", &id);
			printf("VENCEDOR = %d\n", getWinner(clnt, id));
		}
		else if (opt == MENUGETSEED){
			int id;
			printf("digite o ID da transacao: ");
			scanf("%d", &id);
			row r = getSeed(clnt, id);
			printf("desafii=  %d\n", r.challenge);
			printf("status = %d\n", r.status);
			printf("%s\n", r.seed);
		}
		else if (opt == MENUMINERAR){
			MINERAR:
				1+1;
				int tID = getTransactionID(clnt);
				int challenge = getChallenge(clnt, tID);
				int resultado = 0;
				//implementar brute force
				challengeTuple ct;
				ct.transactionId = tID;
				printf("transacao atual = %d\n", tID);
				row r = getSeed(clnt, tID);
				printf("desafii=  %d\n", r.challenge);
				printf("status = %d\n", r.status);
				printf("%s\n", r.seed);
				ct.clientID = 777;
				//
				while (resultado == 0){
					if (resultado == 2 || resultado == -1)
						goto MINERAR;
					
					int N = atoi(argv[2]);
					int n_threads = atoi(argv[3]);
					int remainder = N % n_threads;
					int block_size = N/n_threads;
					int acum = 0;
					// CLIENT *clientes[n_threads];
					thread_data tdata[n_threads];
    				pthread_t threads[n_threads];
					
					for (int i = 0; i < n_threads; ++i){
						int cur_block = block_size + (remainder > 0 ? 1: 0);
						tdata[i].id = i;
						tdata[i].x_i = acum;
						tdata[i].x_f = acum + cur_block - 1;
						tdata[i].tID = tID;
						tdata[i].status = -1;
						tdata[i].clnt = clnt_create(argv[1], PROG, VERSAO, "udp");
						remainder--;
						// printf("tamanho bloco %d:%d\n", i, cur_block);
						// printf("intervalo = [%d, %d]\n", acum, acum+cur_block-1);
						acum += cur_block;
						pthread_create(&(threads[i]), NULL, brute, &(tdata[i]));
					}

					for (int i = 0; i < n_threads; ++i){
						printf("CODIGO DA THREAD: %d\n", pthread_join(threads[i], NULL));
					}
					for (int i = 0; i < n_threads; ++i){
						printf("STATUS DA THREAD %d: %d\n", i, tdata[i].status);
						if (tdata[i].status == SUCCESS){
							size_t length = strlen(tdata[i].seed);
							unsigned char hash[SHA_DIGEST_LENGTH];
							SHA1(tdata[i].seed, length, hash);
							printf("ACABOU seed = %s ->", tdata[i].seed);
							for (int i = 0; i < SHA_DIGEST_LENGTH; ++i)
								printf("%02x", hash[i]);
							printf("\n");
							break;
							// printf("")
						}
					}
					threads_flag = RUN_THREADS;
					goto MINERAR;
					
				}
			
		}
	}
	
exit (0);
}
